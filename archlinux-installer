#!/bin/bash

################################################################
#                                                              #
#       Arch Linux Installation Tool for Rock 5 / RK3588       #
#                                                              #
################################################################
# Define variables

# Define main / dev branch
branch=dev

# URL for Kernel and Arch Linux Rootfs
adrepo_url="https://api.github.com/repos/kwankiu/archlinux-installer-rock5/releases/latest"
rootfs_url="http://os.archlinuxarm.org/os/ArchLinuxARM-aarch64-latest.tar.gz"

################################################################
# Tools for formatting / styling

# Define terminal color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;36m'
NC='\033[0m' # No Color

# Option Picker
function select_option {

    # little helpers for terminal print control and key input
    ESC=$( printf "\033")
    cursor_blink_on()  { printf "$ESC[?25h"; }
    cursor_blink_off() { printf "$ESC[?25l"; }
    cursor_to()        { printf "$ESC[$1;${2:-1}H"; }
    print_option()     { printf "   $1 "; }
    print_selected()   { printf "  $ESC[7m $1 $ESC[27m"; }
    get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
    key_input()        { read -s -n3 key 2>/dev/null >&2
                         if [[ $key = $ESC[A ]]; then echo up;    fi
                         if [[ $key = $ESC[B ]]; then echo down;  fi
                         if [[ $key = ""     ]]; then echo enter; fi; }

    # initially print empty new lines (scroll down if at bottom of screen)
    for opt; do printf "\n"; done

    # determine current screen position for overwriting the options
    local lastrow=`get_cursor_row`
    local startrow=$(($lastrow - $#))

    # ensure cursor and input echoing back on upon a ctrl+c during read -s
    trap "cursor_blink_on; stty echo; printf '\n'; exit" 2
    cursor_blink_off

    local selected=0
    while true; do
        # print options by overwriting the last lines
        local idx=0
        for opt; do
            cursor_to $(($startrow + $idx))
            if [ $idx -eq $selected ]; then
                print_selected "$opt"
            else
                print_option "$opt"
            fi
            ((idx++))
        done

        # user key control
        case `key_input` in
            enter) break;;
            up)    ((selected--));
                   if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi;;
            down)  ((selected++));
                   if [ $selected -ge $# ]; then selected=0; fi;;
        esac
    done

    # cursor position back to normal
    cursor_to $lastrow
    printf "\n"
    cursor_blink_on

    return $selected
}

# Echo with colors
colorecho() {
    color="$1"
    text="$2"
    echo -e "${color}${text}${NC}"
}

# Title / Heading
title() {
  clear
  echo "---------------------------------------------------------------------"
  colorecho "$BLUE" "Welcome to Arch Linux Installation Tool for Rock 5 / RK3588"
  echo "---------------------------------------------------------------------"
}

################################################################
# Function to display a list of available disks

wsl_disks() {
    local i
    k=1
    wsl_drive=()
    for i in "${output[@]}"; do
        # Split the data
        IFS=" " read -r part1 part2 part3 <<< "$i"
        
        # Calculate storage size in GB
        part2="$((part2 / 1024 / 1024 / 1024)) GB"
        
        # Trim leading and trailing whitespace from part3
        part3=$(echo "$part3" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        
        # Construct the option string
        option="${part1} - ${part3} (${part2})"

        # Add to Drive List
        wsl_drive+=("${part1}")
        
        # Add the option to the options array
        options+=("${k}) $option")
        k=$((k+1))
    done
}

list_wsl() {
  options=()

  # For WSL
  if [ ! -z "$WSL_DISTRO_NAME" ]; then
    # Get USB Device List from PowerShell
    IFS=$'\n' read -d '' -ra output <<< "$(powershell.exe 'GET-CimInstance -query "SELECT MODEL,SIZE from Win32_DiskDrive"')"
    output=("${output[@]:3:${#output[@]}-5}")

    wsl_disks   
    # set i to k and adjust i to match below
    i=$((k*3-1))
  else
    disks=($(lsblk -rdno NAME,SIZE,MODEL | awk -F' ' '{ if (NF == 2) { $3 = "Unknown" } }1'))
    for ((i=0; i<${#disks[@]}; i+=3)); do
      model=${disks[i+2]//\\x20/ }  # Replace escaped spaces with actual spaces
      options+=("$((i/3+1))) /dev/${disks[i]} - $model (${disks[i+1]})")
    done
  fi

  options+=("Skip (if you want to create an image or already mounted a disk)")
  select_option "${options[@]}"
  choice=$?
  choice=$((choice+1))

  if [[ $choice =~ ^[0-99]+$ && $choice -ge 1 && $choice -le $((i/3+2)) ]]; then
    if [[ $choice -le $((i/3)) ]]; then
      # For WSL
      if [ ! -z "$WSL_DISTRO_NAME" ]; then
       colorecho "$GREEN" "Selected $((choice-1)) Disk ${wsl_drive[(choice-1)]}"
       powershell.exe 'if (!([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) { Start-Process powershell.exe "-NoProfile -ExecutionPolicy Bypass -File `"$PSCommandPath`"" -Verb RunAs; } wsl --mount '${wsl_drive[(choice-1)]}
      fi
      selected_disk="/dev/${disks[((choice-1)*3)]}"
    fi
  else
    colorecho "$RED" "Invalid choice $choice. Please select a valid option."
  fi
}

list_disks() {
  options=()
  disks=($(lsblk -rdno NAME,SIZE,MODEL | awk -F' ' '{ if (NF == 2) { $3 = "Unknown" } }1'))
  for ((i=0; i<${#disks[@]}; i+=3)); do
    model=${disks[i+2]//\\x20/ }  # Replace escaped spaces with actual spaces
    options+=("$((i/3+1))) /dev/${disks[i]} - $model (${disks[i+1]})")
  done
  options+=("$((i/3+1))) Create an (.img) image")
  options+=("$((i/3+2))) Enter disk path manually")

  select_option "${options[@]}"
  choice=$?
  choice=$((choice+1))

  if [[ $choice =~ ^[0-9]+$ && $choice -ge 1 && $choice -le $((i/3+2)) ]]; then
    if [[ $choice -le $((i/3)) ]]; then
      selected_disk="/dev/${disks[((choice-1)*3)]}"
    elif [[ $choice -eq $((i/3+1)) ]]; then
      colorecho "$GREEN" "Creating an (.img) image ..."
      selected_disk="out/archlinux-installer-rock.img"
      img_mount="/dev/loop1"

      if [ ! -d "out" ]; then
        sudo mkdir out
      fi
      
      sudo truncate -s 4G $selected_disk
      colorecho "$GREEN" "Image created at $selected_disk"

      sudo losetup -P $img_mount $selected_disk
      selected_disk=$img_mount
      colorecho "$GREEN" "Image mounted on $selected_disk"
    else
      read -p "Enter the disk path: " selected_disk
      colorecho "$YELLOW" "Manually entered disk path $selected_disk."
    fi
  else
    colorecho "$RED" "Invalid choice $choice. Please select a valid option."
  fi
}


confirm_disk() {
    drive=$selected_disk
    colorecho "$GREEN" "Selected disk $drive."
    colorecho "$YELLOW" "Confirm to install Arch Linux on $drive ?"
    colorecho "$RED" "WARNING : all data on the disk will be deleted"

    options=("Confirm" "Select another disk" "Exit Installer")
    select_option "${options[@]}"
    answer=$?

    if [ "$answer" = 1 ]; then
      title
      colorecho "$GREEN" "Select a disk to install or create an image:"
      list_disks
      title
      confirm_disk
    elif [ "$answer" = 2 ]; then
      echo "Aborted. Exiting ..."
      exit 1
    fi
}

################################################################

install_kernel() {
  kernel_name=$1
  pkg_tar_dir=$(mktemp -d)
  colorecho "$GREEN" "Downloading $kernel_name ..."
  echo -e "y" | ghrel_packages $kernel_name

  pkg_tar=($(echo -e "n" | ghrel_packages $kernel_name | grep .*pkg.*))
  non_pkg=($(echo -e "n" | ghrel_packages $kernel_name | grep $kernel_name | grep -v .*pkg.*))
  
  # Extract kernel
  colorecho "$GREEN" "Extracting $kernel_name ..."

  # Create folder in pkg_tar_dir
  sudo mkdir $pkg_tar_dir/Kernel
  sudo mkdir $pkg_tar_dir/Kernel/linux
  sudo mkdir $pkg_tar_dir/Kernel/linux/boot

  # Manually install Kernel package
  for pkg in "${pkg_tar[@]}"; do
    sudo tar -xf "$pkg" -C "$pkg_tar_dir/Kernel/linux/"
  done

  # Copy initramfs and vmlinuz
  sudo cp -r initramfs-${kernel_name}.img $pkg_tar_dir/Kernel/linux/boot/initramfs-${kernel_name}.img
  sudo cp -r $pkg_tar_dir/Kernel/linux/usr/lib/modules/*/vmlinuz $pkg_tar_dir/Kernel/linux/boot/vmlinuz-${kernel_name}

  # set Boot Partition source dir
  boot_image=$pkg_tar_dir/Kernel/linux/boot

  # Clean up
  sudo rm -rf "${pkg_tar[@]}" "${non_pkg[@]}"
}

# Install Packages from a GitHub Release Repo
ghrel_packages() {

    if [ -z "$1" ]; then
        colorecho "$RED" "Error: No package specified."
        exit 1
    else
        dgpkg=$1
    fi
    
    ghrel_url=("$adrepo_url")
    dgpkg_list=()

    for which_url in "${ghrel_url[@]}"; do
      colorecho "$GREEN" "Fetching $which_url ..."
      dgpkg_list+=($(curl -s "$which_url" | grep -v '.sig' | grep -B 1 ${dgpkg} | grep -oP '"browser_download_url": "\K[^"]+'))
    done

    echo ""
    colorecho "$BLUE" "The following packages will be downloaded:"
    echo ""
    for url in "${dgpkg_list[@]}"; do
        selection=$(basename "$url")
        echo "$selection"
    done
    echo ""
    echo -ne $"${BLUE}Are you sure to download the packages (y/n)?${NC}"
    read answer

    if [ "$answer" = "y" ]; then
        for url in "${dgpkg_list[@]}"; do
            selection=$(basename "$url")
            echo "Downloading $selection"
            curl -LJO "$url"

            if [ ! -z "$2" ]; then
              sudo cp -r $selection $2/$selection
              sudo rm -rf $selection
            fi

        done
    fi

}

################################################################
# Sees if it is a help command or normal command with parameters
if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
  colorecho "$BLUE" "Arch Linux Installation Tool for Rock 5 / RK3588 ($branch)"
  echo "Usage: archlinux-installer <optional_argument>"

  colorecho "$GREEN" "Options"
  echo "-h / --help : Usage and Infomation of this installer."
  echo "-d / --dev : Use latest dev installation script."
  exit 1
elif [ "$1" = "-d" ] || [ "$1" = "--dev" ]; then
  echo "Getting the latest installation script from dev ..."
  bash <(curl -fsSL https://raw.githubusercontent.com/kwankiu/archlinux-installer-rock5/dev/archlinux-installer) $2 $3
elif [ "$1" = "get-pkg" ]; then
    ghrel_packages "$2" "$3"
else
  ################################################################
  # Main Program
  title

# Install required packages

  # For WSL
  if [ ! -z "$WSL_DISTRO_NAME" ]; then
    colorecho "$YELLOW" "Warning: Running on WSL2 is experimental."
    if [ -f /etc/lsb-release ] || [ -x "$(command -v apt-get)" ] || [ -x "$(command -v apt)" ]; then
      colorecho "$YELLOW" "Make sure this is your default WSL distro, else it wont works."
    else
      colorecho "$RED" "Error: Only Debian / Ubuntu Based Distro on WSL2 are supported. Disk listed below will NOT work."
      colorecho "$GREEN" "However, you can still create an image."
    fi
  fi

  # Check if parted is installed
  if ! [ -x "$(command -v parted)" ]; then
    # Check Linux distribution
    colorecho "$YELLOW" "Parted is not found, trying to install..."
    if [ -f /etc/lsb-release ] || [ -x "$(command -v apt-get)" ]; then
      # Debian/Ubuntu-based
      sudo apt-get update
      sudo apt-get install -y parted
    elif [ -f /etc/redhat-release ]; then
      # Red Hat-based
      sudo yum update
      sudo yum install -y parted
    elif [ -f /etc/arch-release ]; then
      # Arch Linux
      sudo pacman -S parted --noconfirm
    elif [ -x "$(command -v apk)" ]; then
      # Alphine-based
      apk add parted
    else
      colorecho "$RED" "Error : We cant find or install parted on your system. Exiting..."
      exit 1
    fi
  fi

  # Check if parted is installed
  if ! [ -x "$(command -v bsdtar)" ]; then
    # Check Linux distribution
    colorecho "$YELLOW" "bsdtar command not found, trying to install..."
    if [ -f /etc/lsb-release ] || [ -x "$(command -v apt-get)" ]; then
      # Debian/Ubuntu-based
      sudo apt-get update
      sudo apt-get install -y libarchive-tools
    elif [ -f /etc/redhat-release ]; then
      # Red Hat-based
      sudo yum update
      sudo yum install -y libarchive-tools
    elif [ -x "$(command -v apk)" ]; then
      # Alphine-based
      apk add libarchive-tools
    else
      colorecho "$RED" "Error : We cant find or install bsdtar on your system. Exiting..."
      exit 1
    fi
  fi

  # Check if mkfs.vat is installed
  if ! [ -x "$(command -v mkfs.vfat)" ]; then
    # Check Linux distribution
    colorecho "$YELLOW" "mkfs.vat command not found, trying to install..."
    if [ -f /etc/lsb-release ] || [ -x "$(command -v apt-get)" ]; then
      # Debian/Ubuntu-based
      sudo apt-get update
      sudo apt-get install -y dosfstools
    elif [ -f /etc/redhat-release ]; then
      # Red Hat-based
      sudo yum update
      sudo yum install -y dosfstools
    elif [ -f /etc/arch-release ]; then
      # Arch Linux
      sudo pacman -S dosfstools --noconfirm
    elif [ -x "$(command -v apk)" ]; then
      # Alphine-based
      apk add parted dosfstools
    else
      colorecho "$RED" "Error : We cant find or install dosfstools (mkfs.vfat) on your system. Exiting..."
      exit 1
    fi
  fi

  ################################################################
  # This runs when there is no parameters specified

  # Choose drive to install / create .img image
  if [ -z $1 ]; then
    if [ ! -z "$WSL_DISTRO_NAME" ]; then
      colorecho "$GREEN" "Mount a Disk to Continue:"
      list_wsl
      colorecho "$GREEN" "If you sees an error, it is normal when your disk doesnt have a windows supported partiton."
      colorecho "$GREEN" "Just Pick the disk that we just mounted."
      colorecho "$GREEN" "Select a disk to install or create an image:"
      list_disks
    else
      colorecho "$GREEN" "Select a disk to install or create an image:"
      list_disks
    fi

    # Confirm Disk
    title
    confirm_disk

  else 
    drive=$1
  fi

  # Install boot partition and kernel
  if [ -z $2 ]; then
      title
      colorecho "$GREEN" "Select a kernel to install:"
      options=("(Recommended) Radxa BSP Kernel (Linux 5.10)" "(WIP) Install other Kernel from repo")
      select_option "${options[@]}"
      answer=$?
  fi

  if [ "$answer" = 0 ] || [ "$2" = "rkbsp" ]; then
    install_kernel "linux-radxa-rkbsp5"
  else
    echo "Enter kernel package name:"
    read answer
    install_kernel $answer
  fi

  ################################################################
  # Main Setup

  title
  root_mount_dir=$(mktemp -d)
  boot_mount_dir=$(mktemp -d)
  boot_img_mount_dir=$(mktemp -d)

  # Unmount all partitions of the specified drive
  colorecho "$GREEN" "Unmounting disk ..."
  partitions=$(ls ${drive}* 2>/dev/null)
  if [ "$partitions" ]; then
    for partition in $partitions; do
      sudo umount $partition 2>/dev/null || true
    done
  fi

  # Create GPT table and partitions
  colorecho "$GREEN" "Formatting and partitioning disk ..."
  echo -e "Yes" | sudo parted $drive mklabel gpt ---pretend-input-tty
  sudo parted $drive mkpart boot fat32 16MiB 500MiB
  sudo parted $drive mkpart rootfs ext4 500MiB 100%
  sudo parted $drive set 1 boot on

  # Find the partitions
  if [ -e $drive"1" ]; then
    root_partition=$drive"2"
    boot_partition=$drive"1"
  else
    root_partition=$drive"p2"
    boot_partition=$drive"p1"	
  fi

  # Format the partitions
  echo -e 'y' |sudo mkfs.ext4 $root_partition 
  sudo mkfs.vfat -F32 $boot_partition
  sudo resize2fs $drive

  title

  # Mount the partitions
  colorecho "$GREEN" "Mounting partition for install ..."
  sudo mount $root_partition $root_mount_dir
  sudo mount $boot_partition $boot_mount_dir

  # Download and extract the latest ArchLinux tarball
  colorecho "$GREEN" "Downloading Arch Linux rootfs ..."
  curl -LJO $rootfs_url

  colorecho "$GREEN" "Copying Arch Linux rootfs ..."
  sudo bsdtar -xpf ArchLinuxARM-aarch64-latest.tar.gz -C $root_mount_dir

  title
  # Extract the boot image
  colorecho "$GREEN" "Copying Boot Partition ..."
  if [ ${boot_image: -4} == ".img" ]; then
    sudo mount $boot_image $boot_img_mount_dir
    sudo cp -R $boot_img_mount_dir/* $boot_mount_dir
    sudo umount $boot_img_mount_dir
    rm -rf $boot_img_mount_dir
  elif [ ${boot_image: -7} == ".tar.gz" ]; then
    # Extract the .tar.gz file to a temporary directory
    boot_tar_dir=$(mktemp -d)
    sudo tar -xf "$boot_image" -C "$boot_tar_dir"

    # Copy contents to boot partition
    sudo cp -r "$boot_tar_dir"/* "$boot_mount_dir"

    # Remove the temporary directory
    sudo rm -rf "$boot_tar_dir"
  else
    # Copy contents to boot partition
    sudo cp -r "$boot_image"/* "$boot_mount_dir"
  fi

  colorecho "$GREEN" "Updating extlinux.conf ..."
  # Find the UUIDs of the root partition
  root_uuid=$(sudo blkid $root_partition | awk '{print $2}' | tr -d '"')
  root_part_uuid=$(sudo blkid -o export $root_partition | grep PARTUUID | awk -F= '{print $2}')

  # Copy extlinux template
  if [ ! -e "$boot_mount_dir/extlinux/extlinux.conf" ]; then
    sudo mv $boot_mount_dir/extlinux/extlinux.arch.template $boot_mount_dir/extlinux/extlinux.conf
  fi

  # Change UUID for extlinux.conf
  echo "Updating UUID for extlinux.conf ..."
  sudo sed -i "s|UUID=\\*\\*CHANGEME\\*\\*|$root_uuid|" $boot_mount_dir/extlinux/extlinux.conf
  sudo sed -i "s|UUID=CHANGEME|$root_uuid|" $boot_mount_dir/extlinux/extlinux.conf

  echo "Info : Root partition UUID: $root_uuid"
  echo "Info : Root partition PARTUUID: $root_part_uuid"

  title
  # Copy kernel files
  colorecho "$GREEN" "Copying Kernel Files ..."
  sudo cp -r $pkg_tar_dir/Kernel/linux/* "$root_mount_dir"
  sudo rm -rf $root_mount_dir/boot/*

  # Download Installer
  colorecho "$GREEN" "Downloading Installer ..."
  curl -LJO https://raw.githubusercontent.com/kwankiu/archlinux-installer-rock5/$branch/tools/arch-rock-installer

  # Copy arch-rock-installer
  colorecho "$GREEN" "Copying Installer ..."
  sudo chmod +x arch-rock-installer
  sudo cp -r "arch-rock-installer" "$root_mount_dir/usr/bin/installer"

  # Remove the temporary directory
  sudo rm -rf "$pkg_tar_dir"

  # Unmount the boot and root partitions
  sudo umount $boot_mount_dir $root_mount_dir

  if [ ! -z "$WSL_DISTRO_NAME" ]; then
    wsl.exe --unmount \\$drive
  fi

  # Clean up
  colorecho "$YELLOW" "Cleaning up temporary files ..."
  sudo rm -rf $boot_mount_dir $root_mount_dir ArchLinuxARM-aarch64-latest.tar.gz arch-rock-installer

  title
  colorecho "$GREEN" "Created Arch Linux Installer to $drive."
  colorecho "$GREEN" "You may now unmount $drive and boot into the system for installation."
  colorecho "$YELLOW" "Tips: To Start Arch Linux Installer, login to root/root and run command 'installer'."
  echo "Please visit https://github.com/kwankiu/archlinux-installer-rock5/README.md for more information."

fi
################################################################