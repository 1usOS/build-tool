#!/bin/bash

################################################################
#                                                              #
#       Arch Linux Installation Tool for Rock 5 / RK3588       #
#                                                              #
################################################################
# Define variables

# Define main / dev branch
branch=dev

# URL for Kernel and Arch Linux Rootfs
adrepo_url="https://api.github.com/repos/kwankiu/archlinux-installer-rock5/releases/latest"
rootfs_url="http://os.archlinuxarm.org/os/ArchLinuxARM-aarch64-latest.tar.gz"

################################################################
# Tools for formatting / styling

# Define terminal color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;36m'
NC='\033[0m' # No Color

# Option Picker
function select_option {

    # little helpers for terminal print control and key input
    ESC=$( printf "\033")
    cursor_blink_on()  { printf "$ESC[?25h"; }
    cursor_blink_off() { printf "$ESC[?25l"; }
    cursor_to()        { printf "$ESC[$1;${2:-1}H"; }
    print_option()     { printf "   $1 "; }
    print_selected()   { printf "  $ESC[7m $1 $ESC[27m"; }
    get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
    key_input()        { read -s -n3 key 2>/dev/null >&2
                         if [[ $key = $ESC[A ]]; then echo up;    fi
                         if [[ $key = $ESC[B ]]; then echo down;  fi
                         if [[ $key = ""     ]]; then echo enter; fi; }

    # initially print empty new lines (scroll down if at bottom of screen)
    for opt; do printf "\n"; done

    # determine current screen position for overwriting the options
    local lastrow=`get_cursor_row`
    local startrow=$(($lastrow - $#))

    # ensure cursor and input echoing back on upon a ctrl+c during read -s
    trap "cursor_blink_on; stty echo; printf '\n'; exit" 2
    cursor_blink_off

    local selected=0
    while true; do
        # print options by overwriting the last lines
        local idx=0
        for opt; do
            cursor_to $(($startrow + $idx))
            if [ $idx -eq $selected ]; then
                print_selected "$opt"
            else
                print_option "$opt"
            fi
            ((idx++))
        done

        # user key control
        case `key_input` in
            enter) break;;
            up)    ((selected--));
                   if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi;;
            down)  ((selected++));
                   if [ $selected -ge $# ]; then selected=0; fi;;
        esac
    done

    # cursor position back to normal
    cursor_to $lastrow
    printf "\n"
    cursor_blink_on

    return $selected
}

# Echo with colors
colorecho() {
    color="$1"
    text="$2"
    echo -e "${color}${text}${NC}"
}

# Title / Heading
title() {
  clear
  echo "---------------------------------------------------------------------"
  colorecho "$BLUE" "Welcome to Arch Linux Installation Tool for Rock 5 / RK3588"
  echo "---------------------------------------------------------------------"
}

################################################################
# Function to display a list of available disks

wsl_disks() {
    local i
    k=1
    wsl_drive=()
    for i in "${output[@]}"; do
        # Split the data
        IFS=" " read -r part1 part2 part3 <<< "$i"
        
        # Calculate storage size in GB
        part2="$((part2 / 1024 / 1024 / 1024)) GB"
        
        # Trim leading and trailing whitespace from part3
        part3=$(echo "$part3" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        
        # Construct the option string
        option="${part1} - ${part3} (${part2})"

        # Add to Drive List
        wsl_drive+=("${part1}")
        
        # Add the option to the options array
        options+=("${k}) $option")
        k=$((k+1))
    done
}

list_wsl() {
  options=()

  # For WSL
  if [ ! -z "$WSL_DISTRO_NAME" ]; then
    # Get USB Device List from PowerShell
    IFS=$'\n' read -d '' -ra output <<< "$(powershell.exe 'GET-CimInstance -query "SELECT MODEL,SIZE from Win32_DiskDrive"')"
    output=("${output[@]:3:${#output[@]}-5}")

    wsl_disks   
    # set i to k and adjust i to match below
    i=$((k*3-1))
  else
    disks=($(lsblk -rdno NAME,SIZE,MODEL | awk -F' ' '{ if (NF == 2) { $3 = "Unknown" } }1'))
    for ((i=0; i<${#disks[@]}; i+=3)); do
      model=${disks[i+2]//\\x20/ }  # Replace escaped spaces with actual spaces
      options+=("$((i/3+1))) /dev/${disks[i]} - $model (${disks[i+1]})")
    done
  fi

  options+=("Skip (if you want to create an image or already mounted a disk)")
  select_option "${options[@]}"
  choice=$?
  choice=$((choice+1))

  if [[ $choice =~ ^[0-99]+$ && $choice -ge 1 && $choice -le $((i/3+2)) ]]; then
    if [[ $choice -le $((i/3)) ]]; then
      # For WSL
      if [ ! -z "$WSL_DISTRO_NAME" ]; then
       colorecho "$GREEN" "Selected $((choice-1)) Disk ${wsl_drive[(choice-1)]}"
       powershell.exe 'if (!([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) { Start-Process powershell.exe "-NoProfile -ExecutionPolicy Bypass -File `"$PSCommandPath`"" -Verb RunAs; } wsl --mount '${wsl_drive[(choice-1)]}
      fi
      selected_disk="/dev/${disks[((choice-1)*3)]}"
    fi
  else
    colorecho "$RED" "Invalid choice $choice. Please select a valid option."
  fi
}

list_disks() {
  options=()
  disks=($(lsblk -rdno NAME,SIZE,MODEL | awk -F' ' '{ if (NF == 2) { $3 = "Unknown" } }1'))
  for ((i=0; i<${#disks[@]}; i+=3)); do
    model=${disks[i+2]//\\x20/ }  # Replace escaped spaces with actual spaces
    options+=("$((i/3+1))) /dev/${disks[i]} - $model (${disks[i+1]})")
  done
  options+=("$((i/3+1))) Create an (.img) image")
  options+=("$((i/3+2))) Enter disk path manually")

  select_option "${options[@]}"
  choice=$?
  choice=$((choice+1))

  if [[ $choice =~ ^[0-9]+$ && $choice -ge 1 && $choice -le $((i/3+2)) ]]; then
    if [[ $choice -le $((i/3)) ]]; then
      selected_disk="/dev/${disks[((choice-1)*3)]}"
    elif [[ $choice -eq $((i/3+1)) ]]; then
      # Create Image
      read -p "Image Name (default=archlinux-installer-rock5.img): " selected_disk
      if [ -z "$selected_disk" ]; then
        selected_disk="archlinux-installer-rock5.img"
      else
        selected_disk="$selected_disk"
      fi
      create_img

    else
      read -p "Enter the disk path: " selected_disk
      colorecho "$YELLOW" "Manually entered disk path $selected_disk."
    fi
  else
    colorecho "$RED" "Invalid choice $choice. Please select a valid option."
  fi
}

create_img() {
  
  if [ ! -d "out" ]; then
    mkdir out
  fi
  
  if [ -z "$argsize" ]; then
    img_size="4G"
  else
    img_size=$argsize
  fi

  if [ -z "$argdisk" ]; then
    img_mount="/dev/loop1"
  else
    img_mount=$argdisk
  fi

  if [ ! -z "$argimg" ]; then
    selected_disk=$argimg
  fi

  # Check if out/$selected_disk exists and generate a unique name if needed
  if [ -e "out/$selected_disk" ]; then
      counter=0
      base_name="${selected_disk%.img}"
      new_name="${base_name}.img"

      while [ -e "out/$new_name" ]; do
          counter=$((counter + 1))
          new_name="${base_name}-${counter}.img"
      done

      selected_disk="$new_name"
      echo "Renamed to $selected_disk as file already exists."
  fi

  selected_disk="out/$selected_disk"  
  sudo truncate -s $img_size $selected_disk
  colorecho "$GREEN" "Image created at $selected_disk"
  is_img=$selected_disk

  if losetup -a | grep "$img_mount"; then
    sudo losetup --detach $img_mount
  fi

  sudo losetup -P $img_mount $selected_disk
  selected_disk=$img_mount
  colorecho "$GREEN" "Image mounted on $selected_disk"
}


confirm_disk() {
    drive=$selected_disk
    colorecho "$GREEN" "Selected disk $drive."
    colorecho "$YELLOW" "Confirm to install Arch Linux on $drive ?"
    colorecho "$RED" "WARNING : all data on the disk will be deleted"

    options=("Confirm" "Select another disk" "Exit Installer")
    select_option "${options[@]}"
    answer=$?

    if [ "$answer" = 1 ]; then
      title
      colorecho "$GREEN" "Select a disk to install or create an image:"
      list_disks
      title
      confirm_disk
    elif [ "$answer" = 2 ]; then
      echo "Aborted. Exiting ..."
      exit 1
    fi
}

################################################################

install_kernel() {
  kernel_name=$1
  pkg_tar_dir=$(mktemp -d)
  colorecho "$GREEN" "Downloading $kernel_name ..."
  echo -e "y" | ghrel_packages $kernel_name

  pkg_tar=($(echo -e "n" | ghrel_packages $kernel_name | grep .*pkg.*))
  non_pkg=($(echo -e "n" | ghrel_packages $kernel_name | grep $kernel_name | grep -v .*pkg.*))
  
  # Extract kernel
  colorecho "$GREEN" "Extracting $kernel_name ..."

  # Create folder in pkg_tar_dir
  sudo mkdir $pkg_tar_dir/Kernel
  sudo mkdir $pkg_tar_dir/Kernel/linux
  sudo mkdir $pkg_tar_dir/Kernel/linux/boot

  # Manually install Kernel package
  for pkg in "${pkg_tar[@]}"; do
    sudo tar -xf "$pkg" -C "$pkg_tar_dir/Kernel/linux/"
  done

  # Copy initramfs and vmlinuz
  sudo cp -r initramfs-${kernel_name}.img $pkg_tar_dir/Kernel/linux/boot/initramfs-${kernel_name}.img
  sudo cp -r $pkg_tar_dir/Kernel/linux/usr/lib/modules/*/vmlinuz $pkg_tar_dir/Kernel/linux/boot/vmlinuz-${kernel_name}

  # set Boot source dir
  boot_image=$pkg_tar_dir/Kernel/linux/boot

  # Clean up
  sudo rm -rf "${pkg_tar[@]}" "${non_pkg[@]}"
}

# Install Packages from a GitHub Release Repo
ghrel_packages() {

    if [ -z "$1" ]; then
        colorecho "$RED" "Error: No package specified."
        exit 1
    else
        dgpkg=$1
    fi
    
    ghrel_url=("$adrepo_url")
    dgpkg_list=()

    for which_url in "${ghrel_url[@]}"; do
      colorecho "$GREEN" "Fetching $which_url ..."
      dgpkg_list+=($(curl -s "$which_url" | grep -v '.sig' | grep -B 1 ${dgpkg} | grep -oP '"browser_download_url": "\K[^"]+'))
    done

    echo ""
    colorecho "$BLUE" "The following packages will be downloaded:"
    echo ""
    for url in "${dgpkg_list[@]}"; do
        selection=$(basename "$url")
        echo "$selection"
    done
    echo ""
    echo -ne $"${BLUE}Are you sure to download the packages (y/n)?${NC}"
    read answer

    if [ "$answer" = "y" ]; then
        for url in "${dgpkg_list[@]}"; do
            selection=$(basename "$url")
            echo "Downloading $selection"
            curl -LJO "$url"

            if [ ! -z "$2" ]; then
              sudo cp -r $selection $2/$selection
              sudo rm -rf $selection
            fi

        done
    fi

}

################################################################
# Loop through the arguments
for arg in "$@"; do
  case "$arg" in
    -h | --help)
      colorecho "$BLUE" "Arch Linux Installation Tool for Rock 5 / RK3588 ($branch)"
      echo "Usage: archlinux-installer <optional_argument>"

      colorecho "$GREEN" "Options"
      echo "-h / --help : Usage and Infomation of this Installation Tool."
      echo "-d / --dev : Use latest dev version of this Installation Tool."
      echo "-i / --image : Create a disk image with default image name at out folder."
      echo "-k / --kernel : Create Arch Linux using default kernel option."
      echo "--image=<image_name> : Create a disk image with the specified image name at out folder."
      echo "--size=<image_size> : Set disk image size (default is 4G)."
      echo "--disk=<disk_path> : Create Arch Linux on the specified disk path (or the image mount point when used with -i or --image which is /dev/loop1 by default)."
      echo "--kernel=<kernel_name> : Create Arch Linux using the specified kernel option."
      
      exit 1
      ;;
    -d | --dev)
      echo "Getting the latest installation script from dev ..."
      bash <(curl -fsSL https://raw.githubusercontent.com/kwankiu/archlinux-installer-rock5/dev/archlinux-installer) $@
      exit 1
      ;;
    --get-pkg)
      colorecho "$RED" "For debug only."
      ghrel_packages $2 $3
      exit 1
      ;;
    --image=*)
      argimg="${arg#*=}"
      ;;
    --disk=*)
      argdisk="${arg#*=}"
      ;;
    --size=*)
      argsize="${arg#*=}"
      ;;
    --kernel=*)
      argkrl="${arg#*=}"
      ;;
    --chroot)
      argchroot=1
      ;;
    -i | --image)
      argimg="archlinux-installer-rock5.img"
      ;;
    -k | --kernel)
      argkrl="rkbsp"
      ;;
    -c | --compress)
      argxz=1
      ;;
    -*)
      colorecho "$RED" "Invalid command or argument."
      exit 1
      ;;
  esac
done

  ################################################################
  # Main Program
  title

# Install required packages

  # For WSL
  if [ ! -z "$WSL_DISTRO_NAME" ]; then
    colorecho "$YELLOW" "Warning: Running on WSL2 is experimental."
    if [ -f /etc/lsb-release ] || [ -x "$(command -v apt-get)" ] || [ -x "$(command -v apt)" ]; then
      colorecho "$YELLOW" "Make sure this is your default WSL distro, else it wont works."
    else
      colorecho "$RED" "Error: Only Debian / Ubuntu Based Distro on WSL2 are supported. Disk listed below will NOT work."
      colorecho "$GREEN" "However, you can still create an image."
    fi
  fi

  # Check if parted is installed
  if ! [ -x "$(command -v parted)" ]; then
    # Check Linux distribution
    colorecho "$YELLOW" "Parted is not found, trying to install..."
    if [ -f /etc/lsb-release ] || [ -x "$(command -v apt-get)" ]; then
      # Debian/Ubuntu-based
      sudo apt-get update
      sudo apt-get install -y parted
    elif [ -f /etc/redhat-release ]; then
      # Red Hat-based
      sudo yum update
      sudo yum install -y parted
    elif [ -f /etc/arch-release ]; then
      # Arch Linux
      sudo pacman -S parted --noconfirm
    elif [ -x "$(command -v apk)" ]; then
      # Alphine-based
      apk add parted
    else
      colorecho "$RED" "Error : We cant find or install parted on your system. Exiting..."
      exit 1
    fi
  fi

  # Check if parted is installed
  if ! [ -x "$(command -v bsdtar)" ]; then
    # Check Linux distribution
    colorecho "$YELLOW" "bsdtar command not found, trying to install..."
    if [ -f /etc/lsb-release ] || [ -x "$(command -v apt-get)" ]; then
      # Debian/Ubuntu-based
      sudo apt-get update
      sudo apt-get install -y libarchive-tools
    elif [ -f /etc/redhat-release ]; then
      # Red Hat-based
      sudo yum update
      sudo yum install -y libarchive-tools
    elif [ -x "$(command -v apk)" ]; then
      # Alphine-based
      apk add libarchive-tools
    else
      colorecho "$RED" "Error : We cant find or install bsdtar on your system. Exiting..."
      exit 1
    fi
  fi

  # Check if mkfs.vat is installed
  if ! [ -x "$(command -v mkfs.vfat)" ]; then
    # Check Linux distribution
    colorecho "$YELLOW" "mkfs.vat command not found, trying to install..."
    if [ -f /etc/lsb-release ] || [ -x "$(command -v apt-get)" ]; then
      # Debian/Ubuntu-based
      sudo apt-get update
      sudo apt-get install -y dosfstools
    elif [ -f /etc/redhat-release ]; then
      # Red Hat-based
      sudo yum update
      sudo yum install -y dosfstools
    elif [ -f /etc/arch-release ]; then
      # Arch Linux
      sudo pacman -S dosfstools --noconfirm
    elif [ -x "$(command -v apk)" ]; then
      # Alphine-based
      apk add parted dosfstools
    else
      colorecho "$RED" "Error : We cant find or install dosfstools (mkfs.vfat) on your system. Exiting..."
      exit 1
    fi
  fi

  ################################################################
  # This runs when there is no parameters specified

  # Choose drive to install / create .img image
  if [ -z "$argimg" ] && [ -z "$argdisk" ]; then
    if [ ! -z "$WSL_DISTRO_NAME" ]; then
      colorecho "$GREEN" "Mount a Disk to Continue:"
      list_wsl
      colorecho "$GREEN" "If you sees an error, it is normal when your disk doesnt have a windows supported partiton."
      colorecho "$GREEN" "Just Pick the disk that we just mounted."
      colorecho "$GREEN" "Select a disk to install or create an image:"
      list_disks
    else
      colorecho "$GREEN" "Select a disk to install or create an image:"
      list_disks
    fi

    # Confirm Disk
    title
    confirm_disk
  elif [ -z "$argimg" ]; then
    drive=$argdisk
  else
    create_img
    drive=$selected_disk
  fi

  # Install boot partition and kernel
  if [ -z "$argkrl" ]; then
      title
      colorecho "$GREEN" "Select a kernel to install:"
      options=("(Recommended) Radxa BSP Kernel (Linux 5.10)" "(WIP) Install other Kernel from repo")
      select_option "${options[@]}"
      answer=$?
  else
      answer=99
  fi

  if [ "$answer" = 0 ] || [ "$argkrl" = "rkbsp" ]; then
    install_kernel "linux-radxa-rkbsp5"
  else
    if [ -z "$argkrl" ]; then
      read -p "Enter kernel package name:" answer
    else
      answer=$argkrl
    fi
    install_kernel $answer
  fi

  ################################################################
  # Main Setup
  title
  root_mount_dir=$(mktemp -d)
  #boot_mount_dir=$(mktemp -d)

  # Unmount all partitions of the specified drive
  colorecho "$GREEN" "Unmounting disk ..."
  partitions=$(ls ${drive}* 2>/dev/null)
  if [ "$partitions" ]; then
    for partition in $partitions; do
      sudo umount $partition 2>/dev/null || true
    done
  fi

  # Create GPT table and partitions
  colorecho "$GREEN" "Formatting and partitioning disk ..."
  echo -e "Yes" | sudo parted $drive mklabel gpt ---pretend-input-tty
  sudo parted $drive mkpart config fat32 16MiB 32MiB
  sudo parted $drive mkpart rootfs ext4 32MiB 100%
  sudo parted $drive set 2 boot on

  # Find the partitions
  if [ -e $drive"1" ]; then
    root_partition=$drive"2"
    boot_partition=$drive"1"
  else
    root_partition=$drive"p2"
    boot_partition=$drive"p1"	
  fi

  # Format the partitions
  echo -e 'y' |sudo mkfs.ext4 $root_partition 
  sudo mkfs.vfat -F32 $boot_partition
  sudo resize2fs $drive

  title
  # Mount the partitions
  colorecho "$GREEN" "Mounting partition for install ..."
  sudo mount -o rw $root_partition $root_mount_dir
  #sudo mount $boot_partition $boot_mount_dir

  # Download and extract the latest ArchLinux tarball
  colorecho "$GREEN" "Downloading Arch Linux rootfs ..."
  curl -LJO $rootfs_url

  colorecho "$GREEN" "Copying Arch Linux rootfs ..."
  sudo bsdtar -xpf ArchLinuxARM-aarch64-latest.tar.gz -C $root_mount_dir
  sudo rm -rf $root_mount_dir/boot/*

  # Copy kernel files
  colorecho "$GREEN" "Copying Linux Kernel ..."
  sudo cp -r $pkg_tar_dir/Kernel/linux/* "$root_mount_dir"

  title
  colorecho "$GREEN" "Updating extlinux.conf ..."
  # Find the UUIDs of the root partition
  root_uuid=$(sudo blkid $root_partition | awk '{print $2}' | tr -d '"')
  root_part_uuid=$(sudo blkid -o export $root_partition | grep PARTUUID | awk -F= '{print $2}')

  # Copy extlinux template
  if [ ! -e "$root_mount_dir/boot/extlinux/extlinux.conf" ]; then
    sudo mv $root_mount_dir/boot/extlinux/extlinux.arch.template $root_mount_dir/boot/extlinux/extlinux.conf
  fi

  # Change UUID for extlinux.conf
  echo "Updating UUID for extlinux.conf ..."
  sudo sed -i "s|UUID=\\*\\*CHANGEME\\*\\*|$root_uuid|" $root_mount_dir/boot/extlinux/extlinux.conf
  sudo sed -i "s|UUID=CHANGEME|$root_uuid|" $root_mount_dir/boot/extlinux/extlinux.conf

  sudo sed -i "s| /vmlinuz| /boot/vmlinuz|" $root_mount_dir/boot/extlinux/extlinux.conf

  sudo sed -i "s| /initramfs| /boot/initramfs|" $root_mount_dir/boot/extlinux/extlinux.conf
  sudo sed -i "s| /initrd| /boot/initrd|" $root_mount_dir/boot/extlinux/extlinux.conf

  sudo sed -i "s| /dtbs| /boot/dtbs|" $root_mount_dir/boot/extlinux/extlinux.conf
  sudo sed -i "s| /dtbo| /boot/dtbo|" $root_mount_dir/boot/extlinux/extlinux.conf

  echo "Info : Root partition UUID: $root_uuid"
  echo "Info : Root partition PARTUUID: $root_part_uuid"

  title
  # Download Installer
  colorecho "$GREEN" "Downloading Installer ..."
  curl -LJO https://raw.githubusercontent.com/kwankiu/archlinux-installer-rock5/$branch/tools/arch-rock-installer

  # Copy arch-rock-installer
  colorecho "$GREEN" "Copying Installer ..."
  sudo chmod +x arch-rock-installer
  sudo cp -r "arch-rock-installer" "$root_mount_dir/usr/bin/installer"

  if [ "$is_img" = 1 ]; then
    colorecho "$GREEN" "Downloading growpart ..."
    curl -LJO https://raw.githubusercontent.com/canonical/cloud-utils/main/bin/growpart
    colorecho "$GREEN" "Copying growpart ..."
    sudo chmod +x growpart
    sudo cp -r "growpart" "$root_mount_dir/usr/bin/growpart"
  fi

  # Remove the temporary directory
  sudo rm -rf "$pkg_tar_dir"

  if [ ! -z "$argchroot" ]; then
    colorecho "$GREEN" "Chroot into system ..."
    sleep 1
    sudo chroot $root_mount_dir /bin/bash <<END
    mount -t proc none /proc
    mkdir -p /etc/systemd/system && echo "[Unit]\nDescription=First Boot Installer Service\nAfter=network.target\n\n[Service]\nExecStart=/usr/bin/installer\nType=simple\n\n[Install]\nWantedBy=multi-user.target" | tee $root_mount_dir/etc/systemd/system/first-boot-installer.service
    systemctl enable first-boot-installer.service
END
    sleep 5
  fi

  # Unmount the boot and root partitions
  sudo umount $root_mount_dir
  #sudo umount $boot_mount_dir

  if [ ! -z "$is_img" ]; then
    sudo losetup --detach $drive
    if [ "$argxz" = 1 ]; then
      colorecho "$GREEN" "Compressing Image ..."
      sudo xz -T 0 $is_img
    fi
  elif [ ! -z "$WSL_DISTRO_NAME" ]; then
    wsl.exe --unmount \\$drive
  fi

  # Clean up
  colorecho "$YELLOW" "Cleaning up temporary files ..."
  sudo rm -rf $root_mount_dir ArchLinuxARM-aarch64-latest.tar.gz arch-rock-installer growpart
  #sudo rm -rf $boot_mount_dir

  title
  colorecho "$GREEN" "Created Arch Linux Installer to $drive."
  colorecho "$GREEN" "You may now unmount $drive and boot into the system for installation."
  colorecho "$YELLOW" "Tips: To Start Arch Linux Installer, login to root/root and run command 'installer'."
  echo "Please visit https://github.com/kwankiu/archlinux-installer-rock5/README.md for more information."

################################################################